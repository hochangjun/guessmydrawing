import React, { useState, useEffect, useCallback, useRef } from 'react';
import { ReactTogether, useStateTogether, useMyId, useAllNicknames, useConnectedUsers } from 'react-together';
import { PrivyProvider, usePrivy } from '@privy-io/react-auth';
import { ethers } from 'ethers';

// Environment Variables
const PRIVY_APP_ID = import.meta.env.VITE_PRIVY_APP_ID;
const MULTISYNQ_API_KEY = import.meta.env.VITE_MULTISYNQ_API_KEY;
const MULTISYNQ_APP_ID = import.meta.env.VITE_MULTISYNQ_APP_ID;

// Types and Interfaces
interface Point {
  x: number;
  y: number;
}

interface DrawingPath {
  id: string;
  userId: string;
  points: Point[];
  color: string;
  strokeWidth: number;
  timestamp: number;
}

interface Player {
  id: string;
  nickname: string;
  score: number;
  hasPaid: boolean;
  isReady: boolean;
  walletAddress?: string;
}

interface GameState {
  phase: 'lobby' | 'wagering' | 'playing' | 'intermission' | 'finished';
  currentRound: number;
  totalRounds: number;
  currentDrawer: string | null;
  currentWord: string | null;
  timeRemaining: number;
  roundStartTime: number;
  scores: Record<string, number>;
  wagerAmount: number;
  lobbyOwner: string;
  guessedCorrectly: string[];
  sessionCode: string;
}

interface ChatMessage {
  id: string;
  userId: string;
  message: string;
  timestamp: number;
  isGuess: boolean;
  isCorrect?: boolean;
}

// Global window type extension
declare global {
  interface Window {
    ethereum?: any;
  }
}

// Word bank for the game
const WORD_BANK = [
  'cat', 'dog', 'house', 'tree', 'car', 'sun', 'moon', 'star', 'flower', 'bird',
  'fish', 'boat', 'airplane', 'bicycle', 'apple', 'banana', 'pizza', 'burger', 'cake', 'ice cream',
  'guitar', 'piano', 'book', 'pencil', 'computer', 'phone', 'clock', 'key', 'door', 'window',
  'mountain', 'ocean', 'beach', 'forest', 'desert', 'rainbow', 'lightning', 'snowman', 'umbrella', 'balloon',
  'elephant', 'lion', 'tiger', 'monkey', 'dolphin', 'butterfly', 'spider', 'snake', 'rabbit', 'horse'
];

// Monad Testnet Configuration
const MONAD_TESTNET = {
  chainId: '0x279f', // 10143 in hex
  chainName: 'Monad Testnet',
  nativeCurrency: { name: 'MON', symbol: 'MON', decimals: 18 },
  rpcUrls: ['https://testnet-rpc.monad.xyz'],
  blockExplorerUrls: ['https://testnet.monadexplorer.com']
};

// MultiSynq Configuration - Using your existing API key
const MULTISYNQ_CONFIG = {
  appId: 'io.multisynq.guessmydrawing',
  apiKey: '2sEh6UDXdrDn7QUYfQWKSigKShshqcGt3mV3PSSvz2'
};

// Enhanced Drawing Canvas Component
const DrawingCanvas: React.FC<{
  paths: DrawingPath[];
  setPaths: (paths: DrawingPath[]) => void;
  canDraw: boolean;
  color: string;
  strokeWidth: number;
}> = ({ paths, setPaths, canDraw, color, strokeWidth }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentPath, setCurrentPath] = useState<Point[]>([]);
  const myId = useMyId();

  const getMousePos = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const rect = canvas.getBoundingClientRect();
    return {
      x: ((e.clientX - rect.left) / rect.width) * canvas.width,
      y: ((e.clientY - rect.top) / rect.height) * canvas.height
    };
  }, []);

  const startDrawing = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canDraw || !myId) return;
    setIsDrawing(true);
    const pos = getMousePos(e);
    setCurrentPath([pos]);
  }, [canDraw, myId, getMousePos]);

  const draw = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canDraw) return;
    const pos = getMousePos(e);
    setCurrentPath(prev => [...prev, pos]);
  }, [isDrawing, canDraw, getMousePos]);

  const stopDrawing = useCallback(() => {
    if (!isDrawing || !myId || currentPath.length < 2) {
      setIsDrawing(false);
      setCurrentPath([]);
      return;
    }

    const newPath: DrawingPath = {
      id: `${myId}-${Date.now()}-${Math.random()}`,
      userId: myId,
      points: currentPath,
      color,
      strokeWidth,
      timestamp: Date.now()
    };

    setPaths([...paths, newPath]);
    setIsDrawing(false);
    setCurrentPath([]);
  }, [isDrawing, myId, currentPath, color, strokeWidth, paths, setPaths]);

  // Redraw canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas with gradient background
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, '#f8fafc');
    gradient.addColorStop(1, '#e2e8f0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Add grid pattern
    ctx.strokeStyle = '#f1f5f9';
    ctx.lineWidth = 1;
    const gridSize = 20;
    for (let x = 0; x <= canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }

    // Draw all completed paths with shadows
    paths.forEach(path => {
      if (path.points.length < 2) return;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
      ctx.shadowBlur = 2;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      
      ctx.beginPath();
      ctx.moveTo(path.points[0].x, path.points[0].y);
      path.points.forEach(point => ctx.lineTo(point.x, point.y));
      ctx.strokeStyle = path.color;
      ctx.lineWidth = path.strokeWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
    });

    // Draw current path being drawn
    if (currentPath.length > 1) {
      ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
      ctx.shadowBlur = 3;
      ctx.beginPath();
      ctx.moveTo(currentPath[0].x, currentPath[0].y);
      currentPath.forEach(point => ctx.lineTo(point.x, point.y));
      ctx.strokeStyle = color;
      ctx.lineWidth = strokeWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
      ctx.shadowColor = 'transparent';
    }
  }, [paths, currentPath, color, strokeWidth]);

  return (
    <div className="relative">
      <canvas
        ref={canvasRef}
        width={800}
        height={600}
        className={`border-4 border-indigo-200 bg-white rounded-2xl shadow-2xl transition-all duration-300 ${
          canDraw ? 'cursor-crosshair border-indigo-400' : 'cursor-not-allowed border-gray-300'
        }`}
        onMouseDown={startDrawing}
        onMouseMove={draw}
        onMouseUp={stopDrawing}
        onMouseLeave={stopDrawing}
        style={{ maxWidth: '100%', height: 'auto' }}
      />
      {!canDraw && (
        <div className="absolute inset-0 bg-gray-900 bg-opacity-20 rounded-2xl flex items-center justify-center">
          <div className="bg-white px-6 py-3 rounded-full shadow-lg">
            <span className="text-gray-600 font-medium">üé® Watch others draw!</span>
          </div>
        </div>
      )}
    </div>
  );
};

// Enhanced Game Chat Component
const GameChat: React.FC<{
  messages: ChatMessage[];
  onSendMessage: (message: string) => void;
  currentWord: string | null;
  isDrawer: boolean;
  gamePhase: string;
}> = ({ messages, onSendMessage, currentWord, isDrawer, gamePhase }) => {
  const [inputValue, setInputValue] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (inputValue.trim() && !isDrawer && gamePhase === 'playing') {
      onSendMessage(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <div className="bg-white border-2 border-indigo-200 rounded-2xl p-6 h-96 flex flex-col shadow-xl">
      <h3 className="text-xl font-bold mb-4 text-indigo-800 flex items-center">
        üí¨ Game Chat
      </h3>
      <div className="flex-1 overflow-y-auto mb-4 space-y-3 pr-2">
        {messages.map((msg) => (
          <div
            key={msg.id}
            className={`p-3 rounded-xl text-sm transition-all duration-200 ${
              msg.isGuess
                ? msg.isCorrect
                  ? 'bg-green-100 text-green-800 border-l-4 border-green-500 transform scale-105'
                  : 'bg-amber-100 text-amber-800 border-l-4 border-amber-500'
                : 'bg-slate-100 text-slate-800'
            }`}
          >
            <span className="font-bold text-indigo-600">{msg.userId.slice(0, 8)}:</span>{' '}
            <span className={msg.isCorrect ? 'font-bold' : ''}>{msg.message}</span>
            {msg.isCorrect && <span className="ml-2">üéâ</span>}
          </div>
        ))}
        <div ref={messagesEndRef} />
      </div>
      <form onSubmit={handleSubmit} className="flex gap-3">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder={
            isDrawer
              ? "üé® You're drawing! Others will guess."
              : gamePhase === 'playing'
              ? 'üí≠ Type your guess...'
              : '‚è≥ Game not active'
          }
          disabled={isDrawer || gamePhase !== 'playing'}
          className="flex-1 px-4 py-3 border-2 border-indigo-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent disabled:bg-gray-100 transition-all duration-200"
        />
        <button
          type="submit"
          disabled={isDrawer || gamePhase !== 'playing' || !inputValue.trim()}
          className="px-6 py-3 bg-indigo-500 text-white rounded-xl hover:bg-indigo-600 disabled:bg-gray-300 font-medium transition-all duration-200 transform hover:scale-105 disabled:transform-none"
        >
          Send
        </button>
      </form>
    </div>
  );
};

// Enhanced Player List Component
const PlayerList: React.FC<{ players: Player[]; gameState: GameState }> = ({ players, gameState }) => {
  return (
    <div className="bg-white border-2 border-indigo-200 rounded-2xl p-6 shadow-xl">
      <h3 className="text-xl font-bold mb-4 text-indigo-800 flex items-center">
        üë• Players ({players.length}/9)
      </h3>
      <div className="space-y-3">
        {players.map((player) => (
          <div
            key={player.id}
            className={`flex justify-between items-center p-4 rounded-xl transition-all duration-300 ${
              gameState.currentDrawer === player.id
                ? 'bg-gradient-to-r from-indigo-100 to-purple-100 border-2 border-indigo-500 shadow-lg transform scale-105'
                : 'bg-slate-50 border border-slate-200 hover:bg-slate-100'
            }`}
          >
            <div className="flex items-center gap-3">
              <div
                className={`w-4 h-4 rounded-full transition-all duration-200 ${
                  player.hasPaid ? 'bg-green-500 shadow-lg' : 'bg-red-400'
                }`}
              />
              <div className="flex items-center gap-2">
                <span className="font-bold text-slate-800 text-sm">
                  {player.nickname}
                </span>
                {gameState.lobbyOwner === player.id && (
                  <span className="text-xl" title="Lobby Owner">üëë</span>
                )}
                {gameState.currentDrawer === player.id && (
                  <span className="text-lg" title="Currently Drawing">üé®</span>
                )}
              </div>
            </div>
            <span className="text-sm font-black text-indigo-600 bg-indigo-100 px-3 py-1 rounded-full">
              {player.score}pts
            </span>
          </div>
        ))}
      </div>
    </div>
  );
};

// Main Game Component
const GuessMyDrawingGame: React.FC = () => {
  const myId = useMyId();
  const allNicknames = useAllNicknames();
  const { user, authenticated, ready, login, logout } = usePrivy();

  // Game state
  const [gameState, setGameState] = useStateTogether<GameState>('gameState', {
    phase: 'lobby',
    currentRound: 0,
    totalRounds: 3,
    currentDrawer: null,
    currentWord: null,
    timeRemaining: 60,
    roundStartTime: 0,
    scores: {},
    wagerAmount: 0.01,
    lobbyOwner: '',
    guessedCorrectly: [],
    sessionCode: ''
  });

  const [drawingPaths, setDrawingPaths] = useStateTogether<DrawingPath[]>('drawingPaths', []);
  const [players, setPlayers] = useStateTogether<Record<string, Player>>('players', {});
  const [chatMessages, setChatMessages] = useStateTogether<ChatMessage[]>('chatMessages', []);

  // Local state
  const [currentColor, setCurrentColor] = useState('#4f46e5');
  const [strokeWidth, setStrokeWidth] = useState(4);

  // Timer effect
  useEffect(() => {
    let interval: ReturnType<typeof setInterval>;
    if (gameState.phase === 'playing' && gameState.timeRemaining > 0) {
      interval = setInterval(() => {
        setGameState(prev => ({
          ...prev,
          timeRemaining: Math.max(0, prev.timeRemaining - 1)
        }));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [gameState.phase, gameState.timeRemaining, setGameState]);

  // Auto-advance round when time runs out
  useEffect(() => {
    if (gameState.phase === 'playing' && gameState.timeRemaining === 0 && gameState.lobbyOwner === myId) {
      setTimeout(() => nextRound(), 3000);
    }
  }, [gameState.timeRemaining, gameState.phase, gameState.lobbyOwner, myId]);

  // Initialize player when connecting
  useEffect(() => {
    if (myId && authenticated && user && !players[myId]) {
      const walletAddress = user.wallet?.address || '';
      const newPlayer: Player = {
        id: myId,
        nickname: allNicknames[myId] || `Player ${myId.slice(0, 6)}`,
        score: 0,
        hasPaid: false,
        isReady: false,
        walletAddress
      };
      setPlayers(prev => ({ ...prev, [myId]: newPlayer }));

      if (Object.keys(players).length === 0 && !gameState.lobbyOwner) {
        setGameState(prev => ({ ...prev, lobbyOwner: myId }));
      }
    }
  }, [myId, players, allNicknames, setPlayers, gameState.lobbyOwner, setGameState, authenticated, user]);

  // Set session code when component mounts
  useEffect(() => {
    if (!gameState.sessionCode && typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      const sessionFromUrl = urlParams.get('session') || 'DEFAULT';
      setGameState(prev => ({ ...prev, sessionCode: sessionFromUrl }));
    }
  }, [gameState.sessionCode, setGameState]);

  // Blockchain functions
  const switchToMonadTestnet = async () => {
    if (!window.ethereum) return;

    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: MONAD_TESTNET.chainId }],
      });
    } catch (switchError: any) {
      if (switchError.code === 4902) {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [MONAD_TESTNET],
        });
      }
    }
  };

  const payWager = async () => {
    if (!user?.wallet?.address || !myId) return;

    try {
      await switchToMonadTestnet();
      
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const wagerWei = ethers.parseEther(gameState.wagerAmount.toString());

      const tx = await signer.sendTransaction({
        to: '0x0000000000000000000000000000000000000000',
        value: wagerWei,
      });

      await tx.wait();

      setPlayers(prev => ({
        ...prev,
        [myId]: { ...prev[myId], hasPaid: true, isReady: true }
      }));

    } catch (error: any) {
      console.error('Payment failed:', error);
      if (error.message?.includes('insufficient funds')) {
        const userConfirmed = confirm(
          '‚ùå Insufficient funds! You need testnet MON tokens to pay.\n\n' +
          'üéÅ Click OK to get free testnet MON from the faucet, or Cancel to try again later.'
        );
        
        if (userConfirmed) {
          window.open('https://faucet.monad.xyz', '_blank');
        }
      } else {
        alert('Payment failed. Please try again.');
      }
    }
  };

  // Game functions
  const startGame = () => {
    if (gameState.lobbyOwner !== myId) return;
    
    const readyPlayers = Object.values(players).filter((p: Player) => p.hasPaid && p.isReady);
    if (readyPlayers.length < 2) {
      alert('Need at least 2 players to start!');
      return;
    }

    const firstDrawer = readyPlayers[0];
    const word = WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];

    setGameState(prev => ({
      ...prev,
      phase: 'playing',
      currentRound: 1,
      currentDrawer: firstDrawer.id,
      currentWord: word,
      timeRemaining: 60,
      roundStartTime: Date.now(),
      guessedCorrectly: []
    }));

    setDrawingPaths([]);
  };

  const nextRound = () => {
    if (gameState.lobbyOwner !== myId) return;

    const readyPlayers = Object.values(players).filter((p: Player) => p.hasPaid && p.isReady);
    const currentDrawerIndex = readyPlayers.findIndex((p: Player) => p.id === gameState.currentDrawer);
    const nextDrawerIndex = (currentDrawerIndex + 1) % readyPlayers.length;

    if (gameState.currentRound >= gameState.totalRounds) {
      setGameState(prev => ({ ...prev, phase: 'finished' }));
      return;
    }

    const nextDrawer = readyPlayers[nextDrawerIndex];
    const word = WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];

    setGameState(prev => ({
      ...prev,
      currentRound: prev.currentRound + 1,
      currentDrawer: nextDrawer.id,
      currentWord: word,
      timeRemaining: 60,
      roundStartTime: Date.now(),
      guessedCorrectly: []
    }));

    setDrawingPaths([]);
  };

  const sendChatMessage = (message: string) => {
    if (!myId || !gameState.currentWord) return;

    const isGuess = gameState.phase === 'playing' && gameState.currentDrawer !== myId;
    const isCorrect = isGuess && message.toLowerCase() === gameState.currentWord.toLowerCase();

    const chatMessage: ChatMessage = {
      id: `${myId}-${Date.now()}`,
      userId: myId,
      message,
      timestamp: Date.now(),
      isGuess,
      isCorrect
    };

    setChatMessages(prev => [...prev, chatMessage]);

    if (isCorrect && !gameState.guessedCorrectly.includes(myId)) {
      const timeBonus = Math.max(0, Math.floor((gameState.timeRemaining / 60) * 20));
      const positionBonus = [100, 80, 60, 40][gameState.guessedCorrectly.length] || 40;
      const totalPoints = positionBonus + timeBonus;

      setGameState(prev => ({
        ...prev,
        scores: {
          ...prev.scores,
          [myId]: (prev.scores[myId] || 0) + totalPoints,
          [prev.currentDrawer!]: (prev.scores[prev.currentDrawer!] || 0) + 20
        },
        guessedCorrectly: [...prev.guessedCorrectly, myId]
      }));

      setPlayers(prev => ({
        ...prev,
        [myId]: { ...prev[myId], score: (prev[myId]?.score || 0) + totalPoints }
      }));
    }
  };

  const currentPlayer = players[myId || ''];
  const isDrawer = gameState.currentDrawer === myId;
  const canDraw = isDrawer && gameState.phase === 'playing';

  // Authentication check
  if (!ready) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center">
        <div className="bg-white rounded-2xl shadow-2xl p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="text-center mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
          <div className="text-6xl mb-6">üé®</div>
          <h1 className="text-4xl font-bold text-gray-800 mb-6">
            Guess My Drawing
          </h1>
          <p className="text-gray-600 mb-8">
            A multiplayer drawing & guessing game with blockchain wagering on Monad Testnet
          </p>
          <button
            onClick={login}
            className="w-full py-4 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-2xl font-bold text-lg hover:from-indigo-600 hover:to-purple-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
          >
            üöÄ Connect Wallet & Play
          </button>
        </div>
      </div>
    );
  }

  // Render different phases
  if (gameState.phase === 'lobby') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 p-4">
        <div className="max-w-6xl mx-auto">
          {/* Header */}
          <div className="bg-white rounded-3xl shadow-2xl p-6 mb-6">
            <div className="flex justify-between items-center">
              <div>
                <h1 className="text-4xl font-bold text-gray-800 flex items-center gap-3">
                  üé® Guess My Drawing
                </h1>
                <p className="text-gray-600 mt-2">Session: <span className="font-mono font-bold text-indigo-600">{gameState.sessionCode}</span></p>
              </div>
              <div className="flex items-center gap-4">
                <div className="text-right">
                  <p className="text-sm text-gray-600">Connected as</p>
                  <p className="font-bold text-indigo-600">{user?.wallet?.address?.slice(0, 6)}...{user?.wallet?.address?.slice(-4)}</p>
                </div>
                <button
                  onClick={logout}
                  className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-all duration-200"
                >
                  Logout
                </button>
              </div>
            </div>
          </div>
          
          <div className="grid lg:grid-cols-2 gap-8">
            <div className="space-y-6">
              <div className="bg-white rounded-3xl shadow-2xl p-8">
                <h3 className="text-2xl font-bold mb-6 text-indigo-800 flex items-center gap-2">
                  ‚öôÔ∏è Game Setup
                </h3>
                
                {gameState.lobbyOwner === myId && (
                  <div className="space-y-4 mb-6">
                    <div>
                      <label className="block text-sm font-bold text-gray-700 mb-2">
                        üí∞ Wager Amount (MON)
                      </label>
                      <input
                        type="number"
                        step="0.01"
                        min="0.01"
                        value={gameState.wagerAmount}
                        onChange={(e) => setGameState(prev => ({
                          ...prev,
                          wagerAmount: parseFloat(e.target.value) || 0.01
                        }))}
                        className="w-full px-4 py-3 border-2 border-indigo-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-lg font-bold"
                      />
                    </div>
                  </div>
                )}

                <div className="bg-gradient-to-r from-indigo-50 to-purple-50 p-6 rounded-2xl border-2 border-indigo-200">
                  <div className="grid grid-cols-2 gap-4 text-center">
                    <div>
                      <p className="text-sm text-indigo-600 font-medium">Wager per Player</p>
                      <p className="text-2xl font-bold text-indigo-800">{gameState.wagerAmount} MON</p>
                    </div>
                    <div>
                      <p className="text-sm text-purple-600 font-medium">Total Prize Pool</p>
                      <p className="text-2xl font-bold text-purple-800">{(gameState.wagerAmount * Object.keys(players).length).toFixed(3)} MON</p>
                    </div>
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-3xl shadow-2xl p-8 space-y-4">
                {!currentPlayer?.hasPaid ? (
                  <button
                    onClick={payWager}
                    className="w-full py-4 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-2xl font-bold text-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
                  >
                    üí≥ Pay Wager ({gameState.wagerAmount} MON)
                  </button>
                ) : (
                  <div className="text-center py-4 bg-green-100 rounded-2xl border-2 border-green-300">
                    <span className="text-green-700 font-bold text-lg">‚úÖ Ready to Play!</span>
                  </div>
                )}

                {gameState.lobbyOwner === myId && (
                  <button
                    onClick={startGame}
                    disabled={Object.values(players).filter((p: Player) => p.hasPaid).length < 2}
                    className="w-full py-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-2xl font-bold text-lg hover:from-blue-600 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-300 transform hover:scale-105 disabled:transform-none shadow-lg"
                  >
                    üöÄ Start Game
                  </button>
                )}
              </div>
            </div>

            <PlayerList players={Object.values(players)} gameState={gameState} />
          </div>
        </div>
      </div>
    );
  }

  if (gameState.phase === 'finished') {
    const winner = Object.values(players).reduce((prev: Player, current: Player) => 
      (current.score > prev.score) ? current : prev
    );

    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 p-4">
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-3xl shadow-2xl p-8">
            <h1 className="text-5xl font-bold text-center mb-8 text-gray-800">
              üèÜ Game Finished!
            </h1>
            
            <div className="text-center space-y-8">
              <div className="bg-gradient-to-r from-yellow-100 to-orange-100 border-4 border-yellow-400 rounded-3xl p-8">
                <h2 className="text-4xl font-bold text-yellow-800 mb-4 flex items-center justify-center gap-3">
                  üéâ Winner: {winner.nickname}
                </h2>
                <p className="text-2xl text-yellow-700 font-bold">
                  Prize: {(gameState.wagerAmount * Object.keys(players).length).toFixed(3)} MON
                </p>
              </div>

              <PlayerList players={Object.values(players)} gameState={gameState} />

              <button
                onClick={() => window.location.reload()}
                className="py-4 px-8 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-2xl font-bold text-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
              >
                üîÑ Play Again
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Playing phase
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Game Header */}
        <div className="bg-white rounded-3xl shadow-2xl p-6 mb-6">
          <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-800 flex items-center gap-3">
              üé® Guess My Drawing
            </h1>
            <div className="flex items-center gap-6">
              <div className="text-center">
                <p className="text-sm text-gray-600">Round</p>
                <p className="text-2xl font-bold text-indigo-600">
                  {gameState.currentRound}/{gameState.totalRounds}
                </p>
              </div>
              <div className="text-center">
                <p className="text-sm text-gray-600">Time</p>
                <p className={`text-3xl font-black ${gameState.timeRemaining <= 10 ? 'text-red-500 animate-pulse' : 'text-blue-600'}`}>
                  {gameState.timeRemaining}s
                </p>
              </div>
            </div>
          </div>
          
          {isDrawer && (
            <div className="mt-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl border-2 border-blue-200">
              <p className="text-blue-800 text-center">
                <span className="font-bold">üéØ Your word:</span>{' '}
                <span className="text-2xl font-black text-indigo-700 bg-white px-4 py-2 rounded-xl shadow-lg">
                  {gameState.currentWord}
                </span>
              </p>
            </div>
          )}
        </div>

        <div className="grid lg:grid-cols-4 gap-6">
          {/* Canvas and Tools */}
          <div className="lg:col-span-3 space-y-6">
            {/* Drawing Tools */}
            {isDrawer && (
              <div className="bg-white rounded-2xl shadow-xl p-6">
                <h3 className="text-lg font-bold text-gray-800 mb-4 flex items-center gap-2">
                  üé® Drawing Tools
                </h3>
                <div className="flex items-center gap-6">
                  <div>
                    <label className="block text-sm font-bold text-gray-700 mb-2">Color</label>
                    <input
                      type="color"
                      value={currentColor}
                      onChange={(e) => setCurrentColor(e.target.value)}
                      className="w-16 h-12 border-2 border-gray-300 rounded-xl cursor-pointer hover:border-indigo-400 transition-all duration-200"
                    />
                  </div>
                  <div className="flex-1">
                    <label className="block text-sm font-bold text-gray-700 mb-2">
                      Brush Size: {strokeWidth}px
                    </label>
                    <input
                      type="range"
                      min="1"
                      max="12"
                      value={strokeWidth}
                      onChange={(e) => setStrokeWidth(parseInt(e.target.value))}
                      className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                    />
                  </div>
                  <button
                    onClick={() => setDrawingPaths([])}
                    className="px-6 py-3 bg-red-500 text-white rounded-xl hover:bg-red-600 font-bold transition-all duration-200 transform hover:scale-105"
                  >
                    üóëÔ∏è Clear
                  </button>
                </div>
              </div>
            )}

            {/* Canvas */}
            <div className="bg-white rounded-3xl shadow-2xl p-6">
              <DrawingCanvas
                paths={drawingPaths}
                setPaths={setDrawingPaths}
                canDraw={canDraw}
                color={currentColor}
                strokeWidth={strokeWidth}
              />
            </div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            <PlayerList players={Object.values(players)} gameState={gameState} />
            <GameChat
              messages={chatMessages}
              onSendMessage={sendChatMessage}
              currentWord={gameState.currentWord}
              isDrawer={isDrawer}
              gamePhase={gameState.phase}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

// Session Selection Component
const SessionSelection: React.FC<{ onJoinSession: (code: string) => void }> = ({ onJoinSession }) => {
  const [sessionCode, setSessionCode] = useState('');
  const { authenticated, ready, login } = usePrivy();

  const handleJoin = () => {
    if (sessionCode.trim()) {
      onJoinSession(sessionCode.trim().toUpperCase());
    }
  };

  const createNewSession = () => {
    const randomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
    onJoinSession(randomCode);
  };

  if (!ready) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center">
        <div className="bg-white rounded-2xl shadow-2xl p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="text-center mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
          <div className="text-6xl mb-6">üé®</div>
          <h1 className="text-4xl font-bold text-gray-800 mb-6">
            Guess My Drawing
          </h1>
          <p className="text-gray-600 mb-8">
            A multiplayer drawing & guessing game with blockchain wagering on Monad Testnet
          </p>
          <button
            onClick={login}
            className="w-full py-4 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-2xl font-bold text-lg hover:from-indigo-600 hover:to-purple-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
          >
            üöÄ Connect Wallet & Play
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center p-4">
      <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
        <div className="text-center mb-8">
          <div className="text-6xl mb-4">üé®</div>
          <h1 className="text-3xl font-bold text-gray-800 mb-2">
            Guess My Drawing
          </h1>
          <p className="text-gray-600">Join or create a game session</p>
        </div>

        <div className="space-y-6">
          <div>
            <label className="block text-sm font-bold text-gray-700 mb-2">
              üîë Enter Lobby Code
            </label>
            <input
              type="text"
              value={sessionCode}
              onChange={(e) => setSessionCode(e.target.value.toUpperCase())}
              placeholder="Enter lobby code..."
              className="w-full px-4 py-3 border-2 border-indigo-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-lg font-mono text-center"
              maxLength={6}
            />
          </div>

          <button
            onClick={handleJoin}
            disabled={!sessionCode.trim()}
            className="w-full py-3 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-xl font-bold text-lg hover:from-blue-600 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-300 transform hover:scale-105 disabled:transform-none shadow-lg"
          >
            üö™ Join Game
          </button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white text-gray-500">or</span>
            </div>
          </div>

          <button
            onClick={createNewSession}
            className="w-full py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl font-bold text-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
          >
            ‚ú® Create New Lobby
          </button>
        </div>
      </div>
    </div>
  );
};

// Game wrapper with session code
const GameWithSession: React.FC<{ sessionCode: string }> = ({ sessionCode }) => {
  return (
    <ReactTogether
      sessionParams={{
        appId: MULTISYNQ_APP_ID,
        apiKey: MULTISYNQ_API_KEY,
        name: `guess-drawing-${sessionCode}`,
        password: `session-${sessionCode}-password`
      }}
      rememberUsers={true}
    >
      <GuessMyDrawingGameWithCode sessionCode={sessionCode} />
    </ReactTogether>
  );
};

// Enhanced Game Component with session code
const GuessMyDrawingGameWithCode: React.FC<{ sessionCode: string }> = ({ sessionCode }) => {
  const myId = useMyId();
  const allNicknames = useAllNicknames();
  const { user, authenticated, ready, login, logout } = usePrivy();

  // Game state
  const [gameState, setGameState] = useStateTogether<GameState>('gameState', {
    phase: 'lobby',
    currentRound: 0,
    totalRounds: 3,
    currentDrawer: null,
    currentWord: null,
    timeRemaining: 60,
    roundStartTime: 0,
    scores: {},
    wagerAmount: 0.01,
    lobbyOwner: '',
    guessedCorrectly: [],
    sessionCode: sessionCode
  });

  const [drawingPaths, setDrawingPaths] = useStateTogether<DrawingPath[]>('drawingPaths', []);
  const [players, setPlayers] = useStateTogether<Record<string, Player>>('players', {});
  const [chatMessages, setChatMessages] = useStateTogether<ChatMessage[]>('chatMessages', []);

  // Local state
  const [currentColor, setCurrentColor] = useState('#4f46e5');
  const [strokeWidth, setStrokeWidth] = useState(4);

  // Timer effect
  useEffect(() => {
    let interval: ReturnType<typeof setInterval>;
    if (gameState.phase === 'playing' && gameState.timeRemaining > 0) {
      interval = setInterval(() => {
        setGameState(prev => ({
          ...prev,
          timeRemaining: Math.max(0, prev.timeRemaining - 1)
        }));
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [gameState.phase, gameState.timeRemaining, setGameState]);

  // Auto-advance round when time runs out
  useEffect(() => {
    if (gameState.phase === 'playing' && gameState.timeRemaining === 0 && gameState.lobbyOwner === myId) {
      setTimeout(() => nextRound(), 3000);
    }
  }, [gameState.timeRemaining, gameState.phase, gameState.lobbyOwner, myId]);

  // Initialize player when connecting
  useEffect(() => {
    if (myId && authenticated && user && !players[myId]) {
      const walletAddress = user.wallet?.address || '';
      const newPlayer: Player = {
        id: myId,
        nickname: allNicknames[myId] || `Player ${myId.slice(0, 6)}`,
        score: 0,
        hasPaid: false,
        isReady: false,
        walletAddress
      };
      setPlayers(prev => ({ ...prev, [myId]: newPlayer }));

      if (Object.keys(players).length === 0 && !gameState.lobbyOwner) {
        setGameState(prev => ({ ...prev, lobbyOwner: myId }));
      }
    }
  }, [myId, players, allNicknames, setPlayers, gameState.lobbyOwner, setGameState, authenticated, user]);

  // Blockchain functions
  const switchToMonadTestnet = async () => {
    if (!window.ethereum) return;

    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: MONAD_TESTNET.chainId }],
      });
    } catch (switchError: any) {
      if (switchError.code === 4902) {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [MONAD_TESTNET],
        });
      }
    }
  };

  const payWager = async () => {
    if (!user?.wallet?.address || !myId) return;

    try {
      await switchToMonadTestnet();
      
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const wagerWei = ethers.parseEther(gameState.wagerAmount.toString());

      const tx = await signer.sendTransaction({
        to: '0x0000000000000000000000000000000000000000',
        value: wagerWei,
      });

      await tx.wait();

      setPlayers(prev => ({
        ...prev,
        [myId]: { ...prev[myId], hasPaid: true, isReady: true }
      }));

    } catch (error: any) {
      console.error('Payment failed:', error);
      if (error.message?.includes('insufficient funds')) {
        const userConfirmed = confirm(
          '‚ùå Insufficient funds! You need testnet MON tokens to pay.\n\n' +
          'üéÅ Click OK to get free testnet MON from the faucet, or Cancel to try again later.'
        );
        
        if (userConfirmed) {
          window.open('https://faucet.monad.xyz', '_blank');
        }
      } else {
        alert('Payment failed. Please try again.');
      }
    }
  };

  // Game functions
  const startGame = () => {
    if (gameState.lobbyOwner !== myId) return;
    
    const readyPlayers = Object.values(players).filter((p: Player) => p.hasPaid && p.isReady);
    if (readyPlayers.length < 2) {
      alert('Need at least 2 players to start!');
      return;
    }

    const firstDrawer = readyPlayers[0];
    const word = WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];

    setGameState(prev => ({
      ...prev,
      phase: 'playing',
      currentRound: 1,
      currentDrawer: firstDrawer.id,
      currentWord: word,
      timeRemaining: 60,
      roundStartTime: Date.now(),
      guessedCorrectly: []
    }));

    setDrawingPaths([]);
  };

  const nextRound = () => {
    if (gameState.lobbyOwner !== myId) return;

    const readyPlayers = Object.values(players).filter((p: Player) => p.hasPaid && p.isReady);
    const currentDrawerIndex = readyPlayers.findIndex((p: Player) => p.id === gameState.currentDrawer);
    const nextDrawerIndex = (currentDrawerIndex + 1) % readyPlayers.length;

    if (gameState.currentRound >= gameState.totalRounds) {
      setGameState(prev => ({ ...prev, phase: 'finished' }));
      return;
    }

    const nextDrawer = readyPlayers[nextDrawerIndex];
    const word = WORD_BANK[Math.floor(Math.random() * WORD_BANK.length)];

    setGameState(prev => ({
      ...prev,
      currentRound: prev.currentRound + 1,
      currentDrawer: nextDrawer.id,
      currentWord: word,
      timeRemaining: 60,
      roundStartTime: Date.now(),
      guessedCorrectly: []
    }));

    setDrawingPaths([]);
  };

  const sendChatMessage = (message: string) => {
    if (!myId || !gameState.currentWord) return;

    const isGuess = gameState.phase === 'playing' && gameState.currentDrawer !== myId;
    const isCorrect = isGuess && message.toLowerCase() === gameState.currentWord.toLowerCase();

    const chatMessage: ChatMessage = {
      id: `${myId}-${Date.now()}`,
      userId: myId,
      message,
      timestamp: Date.now(),
      isGuess,
      isCorrect
    };

    setChatMessages(prev => [...prev, chatMessage]);

    if (isCorrect && !gameState.guessedCorrectly.includes(myId)) {
      const timeBonus = Math.max(0, Math.floor((gameState.timeRemaining / 60) * 20));
      const positionBonus = [100, 80, 60, 40][gameState.guessedCorrectly.length] || 40;
      const totalPoints = positionBonus + timeBonus;

      setGameState(prev => ({
        ...prev,
        scores: {
          ...prev.scores,
          [myId]: (prev.scores[myId] || 0) + totalPoints,
          [prev.currentDrawer!]: (prev.scores[prev.currentDrawer!] || 0) + 20
        },
        guessedCorrectly: [...prev.guessedCorrectly, myId]
      }));

      setPlayers(prev => ({
        ...prev,
        [myId]: { ...prev[myId], score: (prev[myId]?.score || 0) + totalPoints }
      }));
    }
  };

  const currentPlayer = players[myId || ''];
  const isDrawer = gameState.currentDrawer === myId;
  const canDraw = isDrawer && gameState.phase === 'playing';

  // Authentication check
  if (!ready) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center">
        <div className="bg-white rounded-2xl shadow-2xl p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="text-center mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 flex items-center justify-center p-4">
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center">
          <div className="text-6xl mb-6">üé®</div>
          <h1 className="text-4xl font-bold text-gray-800 mb-6">
            Guess My Drawing
          </h1>
          <p className="text-gray-600 mb-8">
            A multiplayer drawing & guessing game with blockchain wagering on Monad Testnet
          </p>
          <button
            onClick={login}
            className="w-full py-4 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-2xl font-bold text-lg hover:from-indigo-600 hover:to-purple-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
          >
            üöÄ Connect Wallet & Play
          </button>
        </div>
      </div>
    );
  }

  // Render different phases exactly like the original GuessMyDrawingGame
  if (gameState.phase === 'lobby') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 p-4">
        <div className="max-w-6xl mx-auto">
          {/* Header */}
          <div className="bg-white rounded-3xl shadow-2xl p-6 mb-6">
            <div className="flex justify-between items-center">
              <div>
                <h1 className="text-4xl font-bold text-gray-800 flex items-center gap-3">
                  üé® Guess My Drawing
                </h1>
                <p className="text-gray-600 mt-2">Session: <span className="font-mono font-bold text-indigo-600">{gameState.sessionCode}</span></p>
              </div>
              <div className="flex items-center gap-4">
                <div className="text-right">
                  <p className="text-sm text-gray-600">Connected as</p>
                  <p className="font-bold text-indigo-600">{user?.wallet?.address?.slice(0, 6)}...{user?.wallet?.address?.slice(-4)}</p>
                </div>
                <button
                  onClick={logout}
                  className="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-all duration-200"
                >
                  Logout
                </button>
              </div>
            </div>
          </div>
          
          <div className="grid lg:grid-cols-2 gap-8">
            <div className="space-y-6">
              <div className="bg-white rounded-3xl shadow-2xl p-8">
                <h3 className="text-2xl font-bold mb-6 text-indigo-800 flex items-center gap-2">
                  ‚öôÔ∏è Game Setup
                </h3>
                
                {gameState.lobbyOwner === myId && (
                  <div className="space-y-4 mb-6">
                    <div>
                      <label className="block text-sm font-bold text-gray-700 mb-2">
                        üí∞ Wager Amount (MON)
                      </label>
                      <input
                        type="number"
                        step="0.01"
                        min="0.01"
                        value={gameState.wagerAmount}
                        onChange={(e) => setGameState(prev => ({
                          ...prev,
                          wagerAmount: parseFloat(e.target.value) || 0.01
                        }))}
                        className="w-full px-4 py-3 border-2 border-indigo-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-lg font-bold"
                      />
                    </div>
                  </div>
                )}

                <div className="bg-gradient-to-r from-indigo-50 to-purple-50 p-6 rounded-2xl border-2 border-indigo-200">
                  <div className="grid grid-cols-2 gap-4 text-center">
                    <div>
                      <p className="text-sm text-indigo-600 font-medium">Wager per Player</p>
                      <p className="text-2xl font-bold text-indigo-800">{gameState.wagerAmount} MON</p>
                    </div>
                    <div>
                      <p className="text-sm text-purple-600 font-medium">Total Prize Pool</p>
                      <p className="text-2xl font-bold text-purple-800">{(gameState.wagerAmount * Object.keys(players).length).toFixed(3)} MON</p>
                    </div>
                  </div>
                </div>
              </div>

              <div className="bg-white rounded-3xl shadow-2xl p-8 space-y-4">
                {!currentPlayer?.hasPaid ? (
                  <button
                    onClick={payWager}
                    className="w-full py-4 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-2xl font-bold text-lg hover:from-green-600 hover:to-emerald-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
                  >
                    üí≥ Pay Wager ({gameState.wagerAmount} MON)
                  </button>
                ) : (
                  <div className="text-center py-4 bg-green-100 rounded-2xl border-2 border-green-300">
                    <span className="text-green-700 font-bold text-lg">‚úÖ Ready to Play!</span>
                  </div>
                )}

                {gameState.lobbyOwner === myId && (
                  <button
                    onClick={startGame}
                    disabled={Object.values(players).filter((p: Player) => p.hasPaid).length < 2}
                    className="w-full py-4 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-2xl font-bold text-lg hover:from-blue-600 hover:to-indigo-700 disabled:from-gray-400 disabled:to-gray-500 transition-all duration-300 transform hover:scale-105 disabled:transform-none shadow-lg"
                  >
                    üöÄ Start Game
                  </button>
                )}
              </div>
            </div>

            <PlayerList players={Object.values(players)} gameState={gameState} />
          </div>
        </div>
      </div>
    );
  }

  if (gameState.phase === 'finished') {
    const winner = Object.values(players).reduce((prev: Player, current: Player) => 
      (current.score > prev.score) ? current : prev
    );

    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-600 via-blue-600 to-indigo-800 p-4">
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-3xl shadow-2xl p-8">
            <h1 className="text-5xl font-bold text-center mb-8 text-gray-800">
              üèÜ Game Finished!
            </h1>
            
            <div className="text-center space-y-8">
              <div className="bg-gradient-to-r from-yellow-100 to-orange-100 border-4 border-yellow-400 rounded-3xl p-8">
                <h2 className="text-4xl font-bold text-yellow-800 mb-4 flex items-center justify-center gap-3">
                  üéâ Winner: {winner.nickname}
                </h2>
                <p className="text-2xl text-yellow-700 font-bold">
                  Prize: {(gameState.wagerAmount * Object.keys(players).length).toFixed(3)} MON
                </p>
              </div>

              <PlayerList players={Object.values(players)} gameState={gameState} />

              <button
                onClick={() => window.location.reload()}
                className="py-4 px-8 bg-gradient-to-r from-blue-500 to-indigo-600 text-white rounded-2xl font-bold text-lg hover:from-blue-600 hover:to-indigo-700 transition-all duration-300 transform hover:scale-105 shadow-lg"
              >
                üîÑ Play Again
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Playing phase
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Game Header */}
        <div className="bg-white rounded-3xl shadow-2xl p-6 mb-6">
          <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-800 flex items-center gap-3">
              üé® Guess My Drawing
            </h1>
            <div className="flex items-center gap-6">
              <div className="text-center">
                <p className="text-sm text-gray-600">Round</p>
                <p className="text-2xl font-bold text-indigo-600">
                  {gameState.currentRound}/{gameState.totalRounds}
                </p>
              </div>
              <div className="text-center">
                <p className="text-sm text-gray-600">Time</p>
                <p className={`text-3xl font-black ${gameState.timeRemaining <= 10 ? 'text-red-500 animate-pulse' : 'text-blue-600'}`}>
                  {gameState.timeRemaining}s
                </p>
              </div>
            </div>
          </div>
          
          {isDrawer && (
            <div className="mt-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl border-2 border-blue-200">
              <p className="text-blue-800 text-center">
                <span className="font-bold">üéØ Your word:</span>{' '}
                <span className="text-2xl font-black text-indigo-700 bg-white px-4 py-2 rounded-xl shadow-lg">
                  {gameState.currentWord}
                </span>
              </p>
            </div>
          )}
        </div>

        <div className="grid lg:grid-cols-4 gap-6">
          {/* Canvas and Tools */}
          <div className="lg:col-span-3 space-y-6">
            {/* Drawing Tools */}
            {isDrawer && (
              <div className="bg-white rounded-2xl shadow-xl p-6">
                <h3 className="text-lg font-bold text-gray-800 mb-4 flex items-center gap-2">
                  üé® Drawing Tools
                </h3>
                <div className="flex items-center gap-6">
                  <div>
                    <label className="block text-sm font-bold text-gray-700 mb-2">Color</label>
                    <input
                      type="color"
                      value={currentColor}
                      onChange={(e) => setCurrentColor(e.target.value)}
                      className="w-16 h-12 border-2 border-gray-300 rounded-xl cursor-pointer hover:border-indigo-400 transition-all duration-200"
                    />
                  </div>
                  <div className="flex-1">
                    <label className="block text-sm font-bold text-gray-700 mb-2">
                      Brush Size: {strokeWidth}px
                    </label>
                    <input
                      type="range"
                      min="1"
                      max="12"
                      value={strokeWidth}
                      onChange={(e) => setStrokeWidth(parseInt(e.target.value))}
                      className="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                    />
                  </div>
                  <button
                    onClick={() => setDrawingPaths([])}
                    className="px-6 py-3 bg-red-500 text-white rounded-xl hover:bg-red-600 font-bold transition-all duration-200 transform hover:scale-105"
                  >
                    üóëÔ∏è Clear
                  </button>
                </div>
              </div>
            )}

            {/* Canvas */}
            <div className="bg-white rounded-3xl shadow-2xl p-6">
              <DrawingCanvas
                paths={drawingPaths}
                setPaths={setDrawingPaths}
                canDraw={canDraw}
                color={currentColor}
                strokeWidth={strokeWidth}
              />
            </div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            <PlayerList players={Object.values(players)} gameState={gameState} />
            <GameChat
              messages={chatMessages}
              onSendMessage={sendChatMessage}
              currentWord={gameState.currentWord}
              isDrawer={isDrawer}
              gamePhase={gameState.phase}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

// App wrapper with MultiSynq and Privy
const App: React.FC = () => {
  const [sessionCode, setSessionCode] = useState('');
  const [isConnected, setIsConnected] = useState(false);

  const handleJoinSession = (code: string) => {
    setSessionCode(code);
    setIsConnected(true);
  };

  if (!isConnected) {
    return (
      <PrivyProvider appId={PRIVY_APP_ID}>
        <SessionSelection onJoinSession={handleJoinSession} />
      </PrivyProvider>
    );
  }

  return (
    <PrivyProvider appId={PRIVY_APP_ID}>
      <GameWithSession sessionCode={sessionCode} />
    </PrivyProvider>
  );
};

export default App; 